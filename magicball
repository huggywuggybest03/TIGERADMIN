
--//====================================================\\--
--||   CREATED BY SHACKLUSTER CONVERTED BY H17S3#2734
--\\====================================================//--
if game.PlaceId ~=155615604 then
    return
end
getgenv().Nullware_ReanimateConfiguration = {
    ["Netless"] = true,
    ["Anti-Fling"] = false,
    ["Hats To Align"] = {},
    ["Head Movement"] = false,
    ["R15 To R6"] = false,
    ["Godmode"] = true
}
loadstring(game:HttpGetAsync("https://gist.githubusercontent.com/M6HqVBcddw2qaN4s/8cd532018277ee9982433eea25a6c14f/raw/sewMjTpJvVBLR96L"))()
repeat wait() until getgenv().NullwareAPI
wait(0.5)
getgenv().NullwareAPI:GetObject("CloneChar", "Humanoid").Died:Connect(function()
    dead = true
end)
mainRemotes = game.ReplicatedStorage
cddd = false
clickedm = false
local mmm = game.Players.LocalPlayer:GetMouse()
mmm.Button1Down:Connect(function()
    if dead == false then
        if cddd == false then
            cddd = true
            clickedm = true
            wait(0.4)
            clickedm = false
            cddd = false
        end
    end
end)
ClickedR = false
meleeRemote = mainRemotes['meleeEvent']
cool = false
spawn(function()
    while wait() do
        if clickedm == true and dead == false then
            if cool == false then
                cool = true
                for i,v in pairs(game.Players:GetPlayers()) do
                    if v then
                        meleeRemote:FireServer(v)
                    end
                end
                wait(0.2)
                cool = false
            end
        end
    end
end)

getgenv().NullwareAPI:SetVelocity("HumanoidRootPart", Vector3.new(10000, 10000, 10000))
local omghack = Instance.new("SelectionBox")
omghack.Color3 = Color3.new(0, 1, 0.0823529)
omghack.LineThickness = 0.09
omghack.SurfaceColor3 =Color3.new(0, 1, 0.0823529)
omghack.Transparency = 0.7
omghack.Name = math.random()
omghack.Visible =true
omghack.Parent = getgenv().NullwareAPI:GetObject("MainChar", "HumanoidRootPart")
omghack.Adornee = getgenv().NullwareAPI:GetObject("MainChar", "HumanoidRootPart")
repeat wait() until getgenv().NullwareAPI:GetObject("MainChar", "HumanoidRootPart")
getgenv().NullwareAPI:GetObject("MainChar", "HumanoidRootPart").Transparency = 0.4
wait(0.4)
dead = false

Player = game:GetService("Players").LocalPlayer
PlayerGui = Player.PlayerGui
Cam = workspace.CurrentCamera
Backpack = Player.Backpack
Character = Player.Character
Humanoid = Character.Humanoid
Mouse = Player:GetMouse()
RootPart = Character.HumanoidRootPart
Torso = Character.Torso
Head = Character.Head
RightArm = Character["Right Arm"]
LeftArm = Character["Left Arm"]
RightLeg = Character["Right Leg"]
LeftLeg = Character["Left Leg"]
RootJoint = RootPart.RootJoint
Neck = Torso.Neck
RightShoulder = Torso["Right Shoulder"]
LeftShoulder = Torso["Left Shoulder"]
RightHip = Torso["Right Hip"]
LeftHip = Torso["Left Hip"]
local TIME = 0
local sick = Instance.new("Sound",Torso)

IT = Instance.new
CF = CFrame.new
VT = Vector3.new
RAD = math.rad
C3 = Color3.new
UD2 = UDim2.new
BRICKC = BrickColor.new
ANGLES = CFrame.Angles
EULER = CFrame.fromEulerAnglesXYZ
COS = math.cos
ACOS = math.acos
SIN = math.sin
ASIN = math.asin
ABS = math.abs
MRANDOM = math.random
FLOOR = math.floor
--//=================================\\
--|| 	      USEFUL VALUES
--\\=================================//

Animation_Speed = 3
Frame_Speed = 0.016666666666666666
local FORCERESET = false
Frame_Speed = 1 / 80 -- (1 / 60) OR (1 / 80)
local Speed = 25
local ROOTC0 = CF(0, 0, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local NECKC0 = CF(0, 1, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local RIGHTSHOULDERC0 = CF(-0.5, 0, 0) * ANGLES(RAD(0), RAD(90), RAD(0))
local LEFTSHOULDERC0 = CF(0.5, 0, 0) * ANGLES(RAD(0), RAD(-90), RAD(0))
local DAMAGEMULTIPLIER = 1
local ANIM = "Idle"
local ATTACK = false
local EQUIPPED = false
local HOLD = false
local COMBO = 1
local Type = "Ban"
local reason = "error"
local Rooted = false
local SINE = 0
local SIZE = 1
local KEYHOLD = false
local CHANGE = 2 / Animation_Speed
local WALKINGANIM = false
local VALUE1 = false
local VALUE2 = false
local ROBLOXIDLEANIMATION = IT("Animation")
ROBLOXIDLEANIMATION.Name = "Roblox Idle Animation"
ROBLOXIDLEANIMATION.AnimationId = "http://www.roblox.com/asset/?id=180435571"
--ROBLOXIDLEANIMATION.Parent = Humanoid
local WEAPONGUI = IT("ScreenGui", PlayerGui)
WEAPONGUI.Name = "BanishV3Gui"
local Characterb = IT("Model")
Characterb.Name = "shackisgaylol"
local CharacterA = IT("Model")
CharacterA.Name = "shackismegagaylol"
local Effects = IT("Folder", CharacterA)
Effects.Name = "Effects"
local Effects2 = IT("Folder", Characterb)
Effects.Name = "Effects"
local ANIMATOR = Humanoid.Animator
local ANIMATE = Character:FindFirstChild("Animate")
local UNANCHOR = true
local TOBANISH = {}
script.Parent = PlayerGui

--//=================================\\
--\\=================================//


--//=================================\\
--|| SAZERENOS' ARTIFICIAL HEARTBEAT
--\\=================================//

ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "ArtificialHB"

script:WaitForChild("ArtificialHB")

frame = Frame_Speed
tf = 0
allowframeloss = false
tossremainder = false
lastframe = tick()
script.ArtificialHB:Fire()

game:GetService("RunService").Heartbeat:connect(function(s, p)
    tf = tf + s
    if tf >= frame then
        if allowframeloss then
            script.ArtificialHB:Fire()
            lastframe = tick()
        else
            for i = 1, math.floor(tf / frame) do
                script.ArtificialHB:Fire()
            end
            lastframe = tick()
        end
        if tossremainder then
            tf = 0
        else
            tf = tf - frame * math.floor(tf / frame)
        end
    end
end)

--//=================================\\
--\\=================================//

--//=================================\\
--|| 	      SOME FUNCTIONS
--\\=================================//

local BODY = {}
for _, c in pairs(Character:GetDescendants()) do
    if c:IsA("BasePart") and c.Name ~= "Handle" then
        if c ~= RootPart and c ~= Torso and c ~= Head and c ~= RightArm and c ~= LeftArm and c ~= RightLeg and c ~= LeftLeg then
            c.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
        end
        table.insert(BODY,{c,c.Parent,c.Material,c.Color,c.Transparency})
    elseif c:IsA("JointInstance") then
        table.insert(BODY,{c,c.Parent,nil,nil,nil})
    end
end
for e = 1, #BODY do
    if BODY[e] ~= nil then
        local STUFF = BODY[e]
        local PART = STUFF[1]
        local PARENT = STUFF[2]
        local MATERIAL = STUFF[3]
        local COLOR = STUFF[4]
        local TRANSPARENCY = STUFF[5]
        if PART.ClassName == "Part" and PART ~= RootPart then
            PART.Material = MATERIAL
            PART.Color = COLOR
            PART.Transparency = TRANSPARENCY
        end
        PART.AncestryChanged:Connect(function()
            PART.Parent = PARENT
        end)
    end
end

function refit()
    Character.Parent = workspace
    for e = 1, #BODY do
        if BODY[e] ~= nil then
            local STUFF = BODY[e]
            local PART = STUFF[1]
            local PARENT = STUFF[2]
            local MATERIAL = STUFF[3]
            local COLOR = STUFF[4]
            local TRANSPARENCY = STUFF[5]
            if PART:IsA("BasePart") and PART ~= RootPart then
                PART.Material = MATERIAL
                PART.Color = COLOR
                PART.Transparency = TRANSPARENCY+EXTRATRANS
            end
            if PART.Parent ~= PARENT then
                Humanoid:remove()
                PART.Parent = PARENT
                Humanoid = IT("Humanoid",Character)
            end
        end
    end
end

function Raycast(POSITION, DIRECTION, RANGE, IGNOREDECENDANTS)
    return workspace:FindPartOnRay(Ray.new(POSITION, DIRECTION.unit * RANGE), IGNOREDECENDANTS)
end

function PositiveAngle(NUMBER)
    if NUMBER >= 0 then
        NUMBER = 0
    end
    return NUMBER
end

function NegativeAngle(NUMBER)
    if NUMBER <= 0 then
        NUMBER = 0
    end
    return NUMBER
end

function Swait(NUMBER)
    if NUMBER == 0 or NUMBER == nil then
        ArtificialHB.Event:wait()
    else
        for i = 1, NUMBER do
            ArtificialHB.Event:wait()
        end
    end
end

function CreateMesh(MESH, PARENT, MESHTYPE, MESHID, TEXTUREID, SCALE, OFFSET)
    local NEWMESH = IT(MESH)
    if MESH == "SpecialMesh" then
        NEWMESH.MeshType = MESHTYPE
        if MESHID ~= "nil" and MESHID ~= "" then
            NEWMESH.MeshId = "http://www.roblox.com/asset/?id="..MESHID
        end
        if TEXTUREID ~= "nil" and TEXTUREID ~= "" then
            NEWMESH.TextureId = "http://www.roblox.com/asset/?id="..TEXTUREID
        end
    end
    NEWMESH.Offset = OFFSET or VT(0, 0, 0)
    NEWMESH.Scale = SCALE
    NEWMESH.Parent = PARENT
    return NEWMESH
end

function CreatePart(FORMFACTOR, PARENT, MATERIAL, REFLECTANCE, TRANSPARENCY, BRICKCOLOR, NAME, SIZE, ANCHOR)
    local NEWPART = IT("Part")
    NEWPART.formFactor = FORMFACTOR
    NEWPART.Reflectance = REFLECTANCE
    NEWPART.Transparency = TRANSPARENCY
    NEWPART.CanCollide = false
    NEWPART.Locked = true
    NEWPART.Anchored = true
    if ANCHOR == false then
        NEWPART.Anchored = false
    end
    NEWPART.BrickColor = BRICKC(tostring(BRICKCOLOR))
    NEWPART.Name = NAME
    NEWPART.Size = SIZE
    NEWPART.Position = Torso.Position
    NEWPART.Material = MATERIAL
    NEWPART:BreakJoints()
    NEWPART.Parent = PARENT
    return NEWPART
end

local function weldBetween(a, b)
    local weldd = Instance.new("ManualWeld")
    weldd.Part0 = a
    weldd.Part1 = b
    weldd.C0 = CFrame.new()
    weldd.C1 = b.CFrame:inverse() * a.CFrame
    weldd.Parent = a
    return weldd
end


function QuaternionFromCFrame(cf)
    local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
    local trace = m00 + m11 + m22
    if trace > 0 then 
        local s = math.sqrt(1 + trace)
        local recip = 0.5 / s
        return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
    else
        local i = 0
        if m11 > m00 then
            i = 1
        end
        if m22 > (i == 0 and m00 or m11) then
            i = 2
        end
        if i == 0 then
            local s = math.sqrt(m00 - m11 - m22 + 1)
            local recip = 0.5 / s
            return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
        elseif i == 1 then
            local s = math.sqrt(m11 - m22 - m00 + 1)
            local recip = 0.5 / s
            return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
        elseif i == 2 then
            local s = math.sqrt(m22 - m00 - m11 + 1)
            local recip = 0.5 / s return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
        end
    end
end

function QuaternionToCFrame(px, py, pz, x, y, z, w)
    local xs, ys, zs = x + x, y + y, z + z
    local wx, wy, wz = w * xs, w * ys, w * zs
    local xx = x * xs
    local xy = x * ys
    local xz = x * zs
    local yy = y * ys
    local yz = y * zs
    local zz = z * zs
    return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
end

function QuaternionSlerp(a, b, t)
    local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
    local startInterp, finishInterp;
    if cosTheta >= 0.0001 then
        if (1 - cosTheta) > 0.0001 then
            local theta = ACOS(cosTheta)
            local invSinTheta = 1 / SIN(theta)
            startInterp = SIN((1 - t) * theta) * invSinTheta
            finishInterp = SIN(t * theta) * invSinTheta
        else
            startInterp = 1 - t
            finishInterp = t
        end
    else
        if (1 + cosTheta) > 0.0001 then
            local theta = ACOS(-cosTheta)
            local invSinTheta = 1 / SIN(theta)
            startInterp = SIN((t - 1) * theta) * invSinTheta
            finishInterp = SIN(t * theta) * invSinTheta
        else
            startInterp = t - 1
            finishInterp = t
        end
    end
    return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
end

function Clerp(a, b, t)
    local qa = {QuaternionFromCFrame(a)}
    local qb = {QuaternionFromCFrame(b)}
    local ax, ay, az = a.x, a.y, a.z
    local bx, by, bz = b.x, b.y, b.z
    local _t = 1 - t
    return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
end

function CreateFrame(PARENT, TRANSPARENCY, BORDERSIZEPIXEL, POSITION, SIZE, COLOR, BORDERCOLOR, NAME)
    local frame = IT("Frame")
    frame.BackgroundTransparency = TRANSPARENCY
    frame.BorderSizePixel = BORDERSIZEPIXEL
    frame.Position = POSITION
    frame.Size = SIZE
    frame.BackgroundColor3 = COLOR
    frame.BorderColor3 = BORDERCOLOR
    frame.Name = NAME
    frame.Parent = PARENT
    return frame
end

function CreateLabel(PARENT, TEXT, TEXTCOLOR, TEXTFONTSIZE, TEXTFONT, TRANSPARENCY, BORDERSIZEPIXEL, STROKETRANSPARENCY, NAME)
    local label = IT("TextLabel")
    label.BackgroundTransparency = 1
    label.Size = UD2(1, 0, 1, 0)
    label.Position = UD2(0, 0, 0, 0)
    label.TextColor3 = TEXTCOLOR
    label.TextStrokeTransparency = STROKETRANSPARENCY
    label.TextTransparency = TRANSPARENCY
    label.FontSize = TEXTFONTSIZE
    label.Font = TEXTFONT
    label.BorderSizePixel = BORDERSIZEPIXEL
    label.TextScaled = false
    label.Text = TEXT
    label.Name = NAME
    label.Parent = PARENT
    return label
end


function NoOutlines(PART)
    PART.TopSurface, PART.BottomSurface, PART.LeftSurface, PART.RightSurface, PART.FrontSurface, PART.BackSurface = 10, 10, 10, 10, 10, 10
end

function CreateWeldOrSnapOrMotor(TYPE, PARENT, PART0, PART1, C0, C1)
    local NEWWELD = IT(TYPE)
    NEWWELD.Part0 = PART0
    NEWWELD.Part1 = PART1
    NEWWELD.C0 = C0
    NEWWELD.C1 = C1
    NEWWELD.Parent = PARENT
    return NEWWELD
end

local S = IT("Sound")
function CreateSound(ID, PARENT, VOLUME, PITCH, DOESLOOP)
    local NEWSOUND = nil
    coroutine.resume(coroutine.create(function()
        NEWSOUND = S:Clone()
        NEWSOUND.Parent = PARENT
        NEWSOUND.Volume = VOLUME
        NEWSOUND.Pitch = PITCH
        NEWSOUND.SoundId = "http://www.roblox.com/asset/?id="..ID
        NEWSOUND:play()
        if DOESLOOP == true then
            NEWSOUND.Looped = true
        else
            repeat wait(1) until NEWSOUND.Playing == false or NEWSOUND.Parent ~= PARENT
            NEWSOUND:remove()
        end
    end))
    return NEWSOUND
end

function CFrameFromTopBack(at, top, back)
    local right = top:Cross(back)
    return CF(at.x, at.y, at.z, right.x, top.x, back.x, right.y, top.y, back.y, right.z, top.z, back.z)
end

--WACKYEFFECT({EffectType = "", Size = VT(1,1,1), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = 1, CFrame = CF(), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
function WACKYEFFECT(Table)
    local TYPE = (Table.EffectType or "Sphere")
    local SIZE = (Table.Size or VT(1,1,1))
    local ENDSIZE = (Table.Size2 or VT(0,0,0))
    local TRANSPARENCY = (Table.Transparency or 0)
    local ENDTRANSPARENCY = (Table.Transparency2 or 1)
    local CFRAME = (Table.CFrame or Torso.CFrame)
    local MOVEDIRECTION = (Table.MoveToPos or nil)
    local ROTATION1 = (Table.RotationX or 0)
    local ROTATION2 = (Table.RotationY or 0)
    local ROTATION3 = (Table.RotationZ or 0)
    local MATERIAL = (Table.Material or "Neon")
    local COLOR = (Table.Color or C3(1,1,1))
    local TIME = (Table.Time or 45)
    local SOUNDID = (Table.SoundID or nil)
    local SOUNDPITCH = (Table.SoundPitch or nil)
    local SOUNDVOLUME = (Table.SoundVolume or nil)
    coroutine.resume(coroutine.create(function()
        local PLAYSSOUND = false
        local SOUND = nil
        local EFFECT = CreatePart(3, Effects, MATERIAL, 0, TRANSPARENCY, BRICKC("Pearl"), "Effect", VT(1,1,1), true)
        if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
            PLAYSSOUND = true
            SOUND = CreateSound(SOUNDID, EFFECT, SOUNDVOLUME, SOUNDPITCH, false)
        end
        EFFECT.Color = COLOR
        local MSH = nil
        if TYPE == "Sphere" then
            MSH = CreateMesh("SpecialMesh", EFFECT, "Sphere", "", "", SIZE, VT(0,0,0))
        elseif TYPE == "Block" then
            MSH = IT("BlockMesh",EFFECT)
            MSH.Scale = VT(SIZE.X,SIZE.X,SIZE.X)
        elseif TYPE == "Wave" then
            MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "20329976", "", SIZE, VT(0,0,-SIZE.X/8))
        elseif TYPE == "Ring" then
            MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "559831844", "", VT(SIZE.X,SIZE.X,0.1), VT(0,0,0))
        elseif TYPE == "Slash" then
            MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662586858", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
        elseif TYPE == "Round Slash" then
            MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662585058", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
        elseif TYPE == "Swirl" then
            MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "1051557", "", SIZE, VT(0,0,0))
        elseif TYPE == "Skull" then
            MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "4770583", "", SIZE, VT(0,0,0))
        elseif TYPE == "Crystal" then
            MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "9756362", "", SIZE, VT(0,0,0))
        end
        if MSH ~= nil then
            local MOVESPEED = nil
            if MOVEDIRECTION ~= nil then
                MOVESPEED = (CFRAME.p - MOVEDIRECTION).Magnitude/TIME
            end
            local GROWTH = SIZE - ENDSIZE
            local TRANS = TRANSPARENCY - ENDTRANSPARENCY
            if TYPE == "Block" then
                EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
            else
                EFFECT.CFrame = CFRAME
            end
            for LOOP = 1, TIME+1 do
                Swait()
                MSH.Scale = MSH.Scale - GROWTH/TIME
                if TYPE == "Wave" then
                    MSH.Offset = VT(0,0,-MSH.Scale.X/8)
                end
                EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
                if TYPE == "Block" then
                    EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
                else
                    EFFECT.CFrame = EFFECT.CFrame*ANGLES(RAD(ROTATION1),RAD(ROTATION2),RAD(ROTATION3))
                end
                if MOVEDIRECTION ~= nil then
                    local ORI = EFFECT.Orientation
                    EFFECT.CFrame = CF(EFFECT.Position,MOVEDIRECTION)*CF(0,0,-MOVESPEED)
                    EFFECT.Orientation = ORI
                end
            end
            if PLAYSSOUND == false then
                EFFECT:remove()
            else
                SOUND.Stopped:Connect(function()
                    EFFECT:remove()
                end)
            end
        else
            if PLAYSSOUND == false then
                EFFECT:remove()
            else
                repeat Swait() until SOUND.Playing == false
                EFFECT:remove()
            end
        end
    end))
end

function MakeForm(PART,TYPE)
    if TYPE == "Cyl" then
        local MSH = IT("CylinderMesh",PART)
    elseif TYPE == "Ball" then
        local MSH = IT("SpecialMesh",PART)
        MSH.MeshType = "Sphere"
    elseif TYPE == "Wedge" then
        local MSH = IT("SpecialMesh",PART)
        MSH.MeshType = "Wedge"
    end
end

function SpawnTrail(FROM,TO,BIG)
    local TRAIL = CreatePart(3, Effects, "Neon", 0, 0.5, "White", "Trail", VT(0,0,0))
    MakeForm(TRAIL,"Cyl")
    local DIST = (FROM - TO).Magnitude
    if BIG == true then
        TRAIL.Size = VT(0.5,DIST,0.5)
    else
        TRAIL.Size = VT(0.25,DIST,0.25)
    end
    TRAIL.CFrame = CF(FROM, TO) * CF(0, 0, -DIST/2) * ANGLES(RAD(90),RAD(0),RAD(0))
    coroutine.resume(coroutine.create(function()
        for i = 1, 5 do
            Swait()
            TRAIL.Transparency = TRAIL.Transparency + 0.1
        end
        TRAIL:remove()
    end))
end

function MagicSphere(SIZE,WAIT,CFRAME,COLOR,GROW)
    local wave = CreatePart(3, Effects, "Neon", 0, 0, BRICKC(COLOR), "Effect", VT(1,1,1), true)
    local mesh = IT("SpecialMesh",wave)
    mesh.MeshType = "Sphere"
    mesh.Scale = SIZE
    mesh.Offset = VT(0,0,0)
    wave.CFrame = CFRAME
    coroutine.resume(coroutine.create(function(PART)
        for i = 1, WAIT do
            Swait()
            mesh.Scale = mesh.Scale + GROW
            wave.Transparency = wave.Transparency + (1/WAIT)
            if wave.Transparency > 0.99 then
                wave:remove()
            end
        end
    end))
end

function MagicSphereCo(SIZE,WAIT,CFRAME,COLOR,GROW)
    local wave = CreatePart(3, Effects, "Neon", 0, 0, BRICKC(COLOR), "Effect", VT(1,1,1), true)
    local mesh = IT("SpecialMesh",wave)
    mesh.MeshType = "Sphere"
    mesh.Scale = SIZE
    mesh.Offset = VT(0,0,0)
    wave.CFrame = CFRAME
    coroutine.resume(coroutine.create(function(PART)
        for i = 1, WAIT do
            Swait()
            mesh.Scale = mesh.Scale + GROW
            wave.Transparency = wave.Transparency + (1/WAIT)
            if wave.Transparency > 0.99 then
                wave:remove()
            end
        end
    end))
end

function MagicBlock(SIZE,WAIT,CFRAME,COLOR,GROW)
    local wave = CreatePart(3, Effects, "ForceField", 0, 0.5, BRICKC(COLOR), "Effect", VT(SIZE,SIZE,SIZE), true)
    local mesh = IT("BlockMesh",wave)
    wave.CFrame = CFRAME * ANGLES(RAD(math.random(-360,360)),RAD(math.random(-360,360)),RAD(math.random(-360,360)))
    coroutine.resume(coroutine.create(function(PART)
        for i = 1, WAIT do
            Swait()
            mesh.Scale = mesh.Scale + GROW
            wave.CFrame = CFRAME * ANGLES(RAD(math.random(-360,360)),RAD(math.random(-360,360)),RAD(math.random(-360,360)))
            wave.Transparency = wave.Transparency + (0.5/WAIT)
            if wave.Transparency > 0.99 then
                wave:remove()
            end
        end
    end))
end

function CreateRing(SIZE, DOESROT, ROT, WAIT, CFRAME, COLOR, GROW)
    local wave = CreatePart(3, Effects, "Neon", 0, 0.5, BRICKC(COLOR), "Effect", VT(0, 0, 0))
    local mesh = CreateMesh("SpecialMesh", wave, "FileMesh", "559831844", "", SIZE, VT(0, 0, 0))
    wave.CFrame = CFRAME
    coroutine.resume(coroutine.create(function(PART)
        for i = 1, WAIT do
            Swait()
            mesh.Scale = mesh.Scale + GROW
            if DOESROT == true then
                wave.CFrame = wave.CFrame * CFrame.fromEulerAnglesXYZ(0, ROT, 0)
            end
            wave.Transparency = wave.Transparency + 0.5 / WAIT
            if wave.Transparency > 0.99 then
                wave:remove()
            end
        end
    end))
end

local DECAL = IT("Decal")
function MagicRing()
    local RING = CreatePart(3, Effects, "Granite", 0, 1, "Maroon", "MagicRing", VT(0,0,0),true)
    local MESH = IT("BlockMesh",RING)
    local BOTTOMTEXTURE = DECAL:Clone()
    BOTTOMTEXTURE.Parent = RING
    BOTTOMTEXTURE.Face = "Bottom"
    BOTTOMTEXTURE.Name = "BottomTexture"
    local TOPTEXTURE = DECAL:Clone()
    TOPTEXTURE.Parent = RING
    TOPTEXTURE.Face = "Top"
    TOPTEXTURE.Name = "TopTexture"
    BOTTOMTEXTURE.Texture = "http://www.roblox.com/asset/?id=1208118228"
    TOPTEXTURE.Texture = "http://www.roblox.com/asset/?id=1208118228"
    BOTTOMTEXTURE.Color3 = C3(0,0,0)
    TOPTEXTURE.Color3 = C3(1,1,1)
    return RING,MESH,TOPTEXTURE,BOTTOMTEXTURE
end

Debris = game:GetService("Debris")

function CastProperRay(StartPos, EndPos, Distance, Ignore)
    local DIRECTION = CF(StartPos,EndPos).lookVector
    return Raycast(StartPos, DIRECTION, Distance, Ignore)
end

function turnto(position)
    RootPart.CFrame=CFrame.new(RootPart.CFrame.p,VT(position.X,RootPart.Position.Y,position.Z)) * CFrame.new(0, 0, 0)
end

function SHAKECAM(POSITION, RANGE, INTENSITY, TIME)
    local CHILDREN = workspace:GetDescendants()
    for index, CHILD in pairs(CHILDREN) do
        if CHILD.ClassName == "Model" then
            local HUM = CHILD:FindFirstChildOfClass("Humanoid")
            if HUM then
                local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
                if TORSO and RANGE >= (TORSO.Position - POSITION).Magnitude then
                    local CAMSHAKER = script.CamShake:Clone()
                    CAMSHAKER.Shake.Value = INTENSITY
                    CAMSHAKER.Timer.Value = TIME
                    CAMSHAKER.Parent = CHILD
                    CAMSHAKER.Disabled = false
                end
            end
        end
    end
end

--//=================================\\
--||	     WEAPON CREATION
--\\=================================//

local Particle = IT("ParticleEmitter",nil)
Particle.Enabled = false
Particle.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0.3),NumberSequenceKeypoint.new(0.3,0),NumberSequenceKeypoint.new(1,1)})
Particle.LightEmission = 0.5
Particle.Rate = 150
Particle.ZOffset = 0.2
Particle.Rotation = NumberRange.new(-180, 180)
Particle.RotSpeed = NumberRange.new(-180, 180)
Particle.Texture = "http://www.roblox.com/asset/?id=304437537"
Particle.Color = ColorSequence.new(C3(0,1,0),C3(0,1.1,0))

--ParticleEmitter({Speed = 5, Drag = 0, Size1 = 1, Size2 = 5, Lifetime1 = 1, Lifetime2 = 1.5, Parent = Torso, Emit = 100, Offset = 360, Enabled = false})
function ParticleEmitter(Table)
    local PRTCL = Particle:Clone()
    local Speed = Table.Speed or 5
    local Drag = Table.Drag or 0
    local Size1 = Table.Size1 or 1
    local Size2 = Table.Size2 or 5
    local Lifetime1 = Table.Lifetime1 or 1
    local Lifetime2 = Table.Lifetime2 or 1.5
    local Parent = Table.Parent or Torso
    local Emit = Table.Emit or 100
    local Offset = Table.Offset or 360
    local Acel = Table.Acel or VT(0,0,0)
    local Enabled = Table.Enabled or false
    PRTCL.Parent = Parent
    PRTCL.Size = NumberSequence.new(Size1,Size2)
    PRTCL.Lifetime = NumberRange.new(Lifetime1,Lifetime2)
    PRTCL.Speed = NumberRange.new(Speed)
    PRTCL.VelocitySpread = Offset
    PRTCL.Drag = Drag
    PRTCL.Acceleration = Acel
    if Enabled == false then
        PRTCL:Emit(Emit)
        Debris:AddItem(PRTCL,Lifetime2)
    else
        PRTCL.Enabled = true
    end
    return PRTCL
end

for _, c in pairs(CharacterA:GetChildren()) do
    if c.ClassName == "Part" then
        c.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
    end
end

CharacterA.Parent = Character

Characterb.Parent = Character


local SKILLTEXTCOLOR = C3(1,1,1)
local SKILLFONT = ""
local SKILLTEXTSIZE = 7

Humanoid.Died:connect(function()
    ATTACK = true
end)

--[[local SKILL1FRAME = CreateFrame(WEAPONGUI, 1, 2, UD2(0.1, 0, 0.90, 0), UD2(0.26, 0, 0.07, 0), C3(0,0,0), C3(0, 0, 0), "Skill 1 Frame")
local SKILL2FRAME = CreateFrame(WEAPONGUI, 1, 2, UD2(0.63, 0, 0.90, 0), UD2(0.26, 0, 0.07, 0), C3(0,0,0), C3(0, 0, 0), "Skill 2 Frame")
local SKILL3FRAME = CreateFrame(WEAPONGUI, 1, 2, UD2(0.215, 0, 0.90, 0), UD2(0.26, 0, 0.07, 0), C3(0,0,0), C3(0, 0, 0), "Skill 3 Frame")
local SKILL4FRAME = CreateFrame(WEAPONGUI, 1, 2, UD2(0.525, 0, 0.90, 0), UD2(0.26, 0, 0.07, 0), C3(0,0,0), C3(0, 0, 0), "Skill 4 Frame")
local SKILL5FRAME = CreateFrame(WEAPONGUI, 1, 2, UD2(0.365, 0, 0.90, 0), UD2(0.26, 0, 0.07, 0), C3(0,0,0), C3(0, 0, 0), "Skill 5 Frame")
]]
--[[local SKILL1TEXT = CreateLabel(SKILL1FRAME, "[Z] Banish Bullet", SKILLTEXTCOLOR, SKILLTEXTSIZE, SKILLFONT, 0, 2, 0.7, "Text 1")
local SKILL2TEXT = CreateLabel(SKILL2FRAME, "[B] Ability 2", SKILLTEXTCOLOR, SKILLTEXTSIZE, SKILLFONT, 0, 2, 0.7, "Text 2")
local SKILL3TEXT = CreateLabel(SKILL3FRAME, "[C] Ability 3", SKILLTEXTCOLOR, SKILLTEXTSIZE, SKILLFONT, 0, 2, 0.7, "Text 3")
local SKILL4TEXT = CreateLabel(SKILL4FRAME, "[V] Ability 4", SKILLTEXTCOLOR, SKILLTEXTSIZE, SKILLFONT, 0, 2, 0.7, "Text 4")
local SKILL5TEXT = CreateLabel(SKILL5FRAME, "[X] Mercy", SKILLTEXTCOLOR, SKILLTEXTSIZE, SKILLFONT, 0, 2, 0.7, "Text 5")
]]

function chatfunc(text)
    local chat = coroutine.wrap(function()
        if Character:FindFirstChild("TalkingBillBoard")~= nil then
            Character:FindFirstChild("TalkingBillBoard"):destroy()
        end
        local Bill = Instance.new("BillboardGui",Character)
        Bill.Size = UDim2.new(0,100,0,40)
        Bill.StudsOffset = Vector3.new(0,3,0)
        Bill.Adornee = Character.Head
        Bill.Name = "TalkingBillBoard"
        local Hehe = Instance.new("TextLabel",Bill)
        Hehe.BackgroundTransparency = 1
        Hehe.BorderSizePixel = 0
        Hehe.Text = ""
        Hehe.Font = "SourceSansItalic"
        Hehe.TextSize = 40
        Hehe.TextStrokeTransparency = 0
        Hehe.Size = UDim2.new(1,0,0.5,0)
        coroutine.resume(coroutine.create(function()
            while Hehe ~= nil do
                Swait()	
                Hehe.Position = UDim2.new(math.random(-.4,.4),math.random(-5,5),.05,math.random(-5,5))	
                Hehe.Rotation = math.random(-5,5)
                Hehe.TextColor3 = Color3.new(0,0,0)
                Hehe.TextStrokeColor3 = Color3.new(1,1,1)
            end
        end))
        for i = 1,string.len(text),1 do
            Swait()
            Hehe.Text = string.sub(text,1,i)
        end
        Swait(90)--Re[math.random(1, 93)]
        for i = 0, 1, .025 do
            Swait()
            Bill.ExtentsOffset = Vector3.new(math.random(-i, i), math.random(-i, i), math.random(-i, i))
            Hehe.TextStrokeTransparency = i
            Hehe.TextTransparency = i
        end
        Bill:Destroy()
    end)
    chat()
end

function onChatted(msg)
    chatfunc(msg)
end

Player.Chatted:connect(onChatted)

function printbye(Name)
    local MESSAGES = {"You cannot struggle, ","Your existance is an insult, ","Fade, ","Your existance is not desired, ","You are not permitted here, ","You are not to decide your fate, ","Be gone, ","You are already dead, ","Your live is an anomaly, ","Don't dare to return, ","Why are you resisting, ","You cannot exist here, ","Why are you struggling, ","Your fate was already decided, ","Goodbye, ","You cannot ignore my command, ","You cannot resist my command, ","You already died, "}
    chatfunc(MESSAGES[MRANDOM(1,#MESSAGES)]..Name..".")	
end

workspace.ChildAdded:connect(function(instance)
    for BANISH = 1, #TOBANISH do
        if TOBANISH[BANISH] ~= nil then
            if instance.Name == TOBANISH[BANISH] then
                coroutine.resume(coroutine.create(function()
                    printbye(instance.Name)
                    instance:ClearAllChildren()
                    Debris:AddItem(instance,0.0005)
                end))
            end
        end
    end
end)

--//=================================\\
--||			DAMAGING
--\\=================================//

function Banish(Foe)
    wait()
end

function ApplyAoE(POSITION,RANGE,ISBANISH)
    local CHILDREN = workspace:GetDescendants()
    for index, CHILD in pairs(CHILDREN) do
        if CHILD.ClassName == "Model" and CHILD ~= Character then
            local HUM = CHILD:FindFirstChildOfClass("Humanoid")
            if HUM then
                local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
                if TORSO then
                    if (TORSO.Position - POSITION).Magnitude <= RANGE then
                        if ISBANISH == true then
                            Banish(CHILD)
                        else
                            if ISBANISH == "Gravity" then
                                HUM.PlatformStand = true
                                if TORSO:FindFirstChild("V3BanishForce"..Player.Name) then
                                    local grav = Instance.new("BodyPosition",TORSO)
                                    grav.D = 15
                                    grav.P = 20000
                                    grav.maxForce = Vector3.new(math.huge,math.huge,math.huge)
                                    grav.position = TORSO.Position
                                    grav.Name = "V3BanishForce"..Player.Name
                                else
                                    TORSO:FindFirstChild("V3BanishForce"..Player.Name).position = TORSO.Position+VT(0,0.3,0)
                                    TORSO.RotVelocity = VT(MRANDOM(-25,25),MRANDOM(-25,25),MRANDOM(-25,25))
                                end
                            else
                                HUM.PlatformStand = false
                            end
                        end
                    elseif ISBANISH == "Gravity" then
                        if TORSO:FindFirstChild("V3BanishForce"..Player.Name) then
                            TORSO:FindFirstChild("V3BanishForce"..Player.Name):remove()
                            HUM.PlatformStand = false
                        end
                    end
                end
            end
        end
    end
end


function ManualDamage(Humanoid,Damage,TorsoPart)
    wait()
end

local asd = Instance.new("ParticleEmitter")
asd.Color = ColorSequence.new(Color3.new(0.5, 0, 0), Color3.new(.3, 0, 0))
asd.LightEmission = .1
asd.Texture = "http://www.roblox.com/asset/?ID=291880914"
aaa = NumberSequence.new({NumberSequenceKeypoint.new(0, 0.6),NumberSequenceKeypoint.new(1, 2)})
bbb = NumberSequence.new({NumberSequenceKeypoint.new(0, 1),NumberSequenceKeypoint.new(0.0636, 0), NumberSequenceKeypoint.new(1, 1)})
asd.Transparency = bbb
asd.Size = aaa
asd.ZOffset = .9
asd.Acceleration = Vector3.new(0, -15, 0)
asd.LockedToPart = false
asd.EmissionDirection = "Back"
asd.Lifetime = NumberRange.new(1, 2)
asd.Rotation = NumberRange.new(-100, 100)
asd.RotSpeed = NumberRange.new(-100, 100)
asd.Speed = NumberRange.new(10)
asd.Enabled = false
asd.VelocitySpread = 999

function getbloody(victim,amount)
    local PART = CreatePart(3, Effects, "Metal", 0, 1, "Mid gray", "Blood", victim.Size)
    PART.CFrame = victim.CFrame
    local HITPLAYERSOUNDS = {"356551938","264486467"}
    Debris:AddItem(PART,5)
    CreateSound(HITPLAYERSOUNDS[MRANDOM(1, #HITPLAYERSOUNDS)], PART, 1, (math.random(8,12)/10))
    CreateSound(HITPLAYERSOUNDS[MRANDOM(1, #HITPLAYERSOUNDS)], PART, 1, (math.random(8,12)/10))
    CreateSound(HITPLAYERSOUNDS[MRANDOM(1, #HITPLAYERSOUNDS)], PART, 1, (math.random(8,12)/10))
    local prtcl = asd:Clone()
    prtcl.Parent = PART
    prtcl:Emit(amount*10)
end

function ManualAoE(POSITION,RANGE,MINDMG,MAXDMG,FLING,INSTAKILL)
    local CHILDREN = workspace:GetDescendants()
    for index, CHILD in pairs(CHILDREN) do
        if CHILD.ClassName == "Model" and CHILD ~= Character and CHILD.Parent ~= Effects then
            local HUM = CHILD:FindFirstChildOfClass("Humanoid")
            if HUM then
                local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
                if TORSO then
                    if (TORSO.Position - POSITION).Magnitude <= RANGE then
                        if INSTAKILL == true then
                            CHILD:BreakJoints()
                        else
                            local DMG = MRANDOM(MINDMG,MAXDMG)
                            ManualDamage(HUM,DMG,TORSO)
                        end
                        if FLING > 0 then
                            for _, c in pairs(CHILD:GetChildren()) do
                                if c:IsA("BasePart") then
                                    local bv = Instance.new("BodyVelocity") 
                                    bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
                                    bv.velocity = CF(POSITION,TORSO.Position).lookVector*FLING
                                    bv.Parent = c
                                    Debris:AddItem(bv,0.05)
                                end
                            end
                        end
                    end
                end
            end
        end
    end
end

local PE=Instance.new("ParticleEmitter",art)
PE.LightEmission=.8
PE.Color = ColorSequence.new(BRICKC("Lime green").Color)
PE.Lifetime=NumberRange.new(0.35,1.5)
PE.Rotation=NumberRange.new(0,360)
PE.Rate=999
PE.VelocitySpread = 10000
PE.Acceleration = Vector3.new(0,0,0)
PE.Drag = 5
PE.Speed = NumberRange.new(0,0,0)
PE.Texture="http://www.roblox.com/asset/?id=833874434"
PE.ZOffset = -1.5
PE.Name = "PE"
PE.Enabled = false

function particles(art)
    local PARTICLES = PE:Clone()
    PARTICLES.Parent = art
end

function KillChildren(v)
    wait()
end

function killnearest(position,range)
    wait()
end

function Dismember(MAN,DOWHAT)
    wait()
end

--//=================================\\
--||	ATTACK FUNCTIONS AND STUFF
--\\=================================//

function Zone()
    ATTACK = true
    Rooted = true
    for i=0, 5, 0.1 / Animation_Speed do
        Swait()
        RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
        Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
        RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(180), RAD(0), RAD(-18)) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
        LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-5), RAD(12), RAD(-12)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
        RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(-9), RAD(82), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
        LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(-9), RAD(-82), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
    end
    ATTACK = false
    Rooted = false
end

function meme()
    local HITFLOOR, HITPOS, NORMAL = Raycast(RootPart.Position, CF(RootPart.Position, RootPart.Position + VT(0, -1, 0)).lookVector, 25, Character)
    if Mouse.Target.Parent ~= Character and Mouse.Target.Parent.Parent ~= Character and Mouse.Target.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
        local HUM = Mouse.Target.Parent:FindFirstChildOfClass("Humanoid")
        local TORSO = HUM.Parent:FindFirstChild("Torso") or HUM.Parent:FindFirstChild("UpperTorso")
        if TORSO and HUM.Health > 0 then
            ATTACK = true
            Rooted = false
            local GYRO = IT("BodyGyro",RootPart)
            GYRO.D = 275
            GYRO.P = 20000
            GYRO.MaxTorque = VT(0,40000,0)
            local grav = Instance.new("BodyPosition",TORSO)
            grav.D = 1500
            grav.P = 20000
            grav.maxForce = Vector3.new(math.huge,math.huge,math.huge)
            grav.position = TORSO.Position+VT(0,15,0)
            local MAGIC = ParticleEmitter({Speed = 5, Drag = 3, Size1 = 1.7, Size2 = 0, Lifetime1 = 1, Lifetime2 = 3, Parent = TORSO, Emit = 100, Offset = 360, Enabled = true})
            MAGIC.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1),NumberSequenceKeypoint.new(1,0)})
            Debris:AddItem(MAGIC,10)
            CreateSound(429459101, TORSO, 0.5, 1, false)
            Debris:AddItem(grav,10)
            for i=0, 2, 0.1 / Animation_Speed do
                Swait()
                GYRO.cframe = CF(RootPart.Position,TORSO.Position)
                RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 3)) * ANGLES(RAD(0), RAD(0), RAD(45)), 1 / Animation_Speed)
                Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(-42)), 1 / Animation_Speed)
                RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.1, 0.5, -0.4) * ANGLES(RAD(90), RAD(0), RAD(-60)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
                LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-12)) * LEFTSHOULDERC0, 1 / Animation_Speed)
                RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 3), -0.01) * ANGLES(RAD(0), RAD(58), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(0)), 1 / Animation_Speed)
                LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 3), -0.01) * ANGLES(RAD(0), RAD(-84), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 1 / Animation_Speed)
            end
            CreateSound(136007472, TORSO, 3, 1.2, false)
            for i=0, 1, 0.1 / Animation_Speed do
                Swait()
                RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 3)) * ANGLES(RAD(0), RAD(3), RAD(55)), 0.15 / Animation_Speed)
                Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(60)), 0.15 / Animation_Speed)
                RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.1, 0.5, -0.4) * ANGLES(RAD(120), RAD(0), RAD(-60)) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
                LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(5), RAD(-13)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
                RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.8 - 0.05 * COS(SINE / 3), -0.01) * ANGLES(RAD(0), RAD(58), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(-15)), 0.15 / Animation_Speed)
                LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 3), -0.01) * ANGLES(RAD(0), RAD(-74), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 0.15 / Animation_Speed)
            end
            CreateSound(2760447541, TORSO, 5, 1, false)
            CreateSound(211134014, TORSO, 5, 1, false)
            CreateSound(211059653, TORSO, 5, 1, false)
            WACKYEFFECT({EffectType = "Sphere", Size = VT(0,0,0), Size2 = VT(25,0.2,1), Transparency = 0, Transparency2 = 1, CFrame = TORSO.CFrame*CF(0,-1,0) * ANGLES(RAD(MRANDOM(-90,90)), RAD(MRANDOM(-90,90)), RAD(MRANDOM(-90,90))), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(0,1,0), SoundID = nil, SoundPitch = 1, SoundVolume = 0})
            WACKYEFFECT({EffectType = "Sphere", Size = VT(6,6,6), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = 1, CFrame = TORSO.CFrame*CF(0,-1,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(0,1,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
            for i=0, 1.5, 0.1 / Animation_Speed do
                Swait()
                RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.8 + 0.05 * COS(SINE / 3)) * ANGLES(RAD(15), RAD(0), RAD(0)), 0.5 / Animation_Speed)
                Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-15), RAD(0), RAD(0)), 0.5 / Animation_Speed)
                RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(85)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
                LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(5), RAD(-15)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
                RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.8 - 0.05 * COS(SINE / 3), -0.8) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(-25)), 0.5 / Animation_Speed)
                LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.8 - 0.05 * COS(SINE / 3), -0.01) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(35)), 0.5 / Animation_Speed)
            end
            getbloody(TORSO,1)
            SHAKECAM(HITPOS, 15, 2, 130)
            killnearest(TORSO.Position, 5, 5)
            WACKYEFFECT({Time = 45, EffectType = "Sphere", Size = VT(0,0,0), Size2 = VT(10,10,10), Transparency = 0, Transparency2 = 1, CFrame = TORSO.CFrame*CF(0,-1,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(0,1,0), SoundID = 0, SoundPitch = MRANDOM(13,15)/10, SoundVolume = 3})
            WACKYEFFECT({EffectType = "Sphere", Size = VT(6,6,6), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = 1, CFrame = TORSO.CFrame*CF(0,-1,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(0,1,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
            GYRO:remove()
            ATTACK = false
            Rooted = false
        end
    end
end

function Taunt()
    ATTACK = true
    Rooted = true
    CreateSound("159882314", Torso, 6, 1)
    for i=0, 2, 0.1 / Animation_Speed do
        Swait()
        RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 3)) * ANGLES(RAD(0), RAD(0), RAD(-25)), 0.15 / Animation_Speed)
        Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-8 - 8 * COS(SINE / 3)), RAD(25), RAD(25)), 0.15 / Animation_Speed)
        RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.1, 0.3 + 0.1 * COS(SINE / 3), 0.2) * ANGLES(RAD(-35), RAD(0), RAD(-50)) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
        LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.1, 0.3 + 0.1 * COS(SINE / 3), 0.2) * ANGLES(RAD(-35), RAD(0), RAD(50)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
        RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 3), -0.01) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 0.15 / Animation_Speed)
        LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 3), -0.01) * ANGLES(RAD(0), RAD(-73), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 0.15 / Animation_Speed)
    end
    ATTACK = false
    Rooted = false
end

function PurgeCombo()
    ATTACK = true
    Rooted = false
    EQUIPPED = true

    local HIT2 = function()
        local HITS2 = {}
        local TOUCH2 = LeftArm.Touched:Connect(function(hit)
            if hit.Parent:FindFirstChildOfClass("Humanoid") and hit.Parent ~= Character then

                --[[
                local HUM = hit.Parent:FindFirstChildOfClass("Humanoid")
                local TORSO = hit.Parent:FindFirstChild("Torso") or hit.Parent:FindFirstChild("UpperTorso")
                if TORSO and HUM.Health > 0 then
                    local PASS = true
                    for i = 1, #HITS2 do
                        if HITS2[i] == hit.Parent then
                            PASS = false
                        end
                    end
                    table.insert(HITS2,hit.Parent)
                    if PASS == true then
                        ManualDamage(HUM,MRANDOM(5,10),HUM.Torso)
                    end
                end
                ]]

            end
        end)
        return TOUCH2
    end
    local HIT = function()
        local HITS = {}
        local TOUCH = RightLeg.Touched:Connect(function(hit)
            if hit.Parent:FindFirstChildOfClass("Humanoid") and hit.Parent ~= Character then

                --[[
                local HUM = hit.Parent:FindFirstChildOfClass("Humanoid")
                local TORSO = hit.Parent:FindFirstChild("Torso") or hit.Parent:FindFirstChild("UpperTorso")
                if TORSO and HUM.Health > 0 then
                    local PASS = true
                    for i = 1, #HITS do
                        if HITS[i] == hit.Parent then
                            PASS = false
                        end
                    end
                    table.insert(HITS,hit.Parent)
                    if PASS == true then
                        ManualDamage(HUM,MRANDOM(10,15),HUM.Torso)
                    end
                end
                ]]

            end
        end)
        return TOUCH
    end
    local HIT3 = function()
        local HITS3 = {}
        local TOUCH3 = LeftLeg.Touched:Connect(function(hit)
            if hit.Parent:FindFirstChildOfClass("Humanoid") and hit.Parent ~= Character then
                --[[
                
                local HUM = hit.Parent:FindFirstChildOfClass("Humanoid")
                local TORSO = hit.Parent:FindFirstChild("Torso") or hit.Parent:FindFirstChild("UpperTorso")
                if TORSO and HUM.Health > 0 then
                    local PASS = true
                    for i = 1, #HITS3 do
                        if HITS3[i] == hit.Parent then
                            PASS = false
                        end
                    end
                    table.insert(HITS3,hit.Parent)
                    if PASS == true then
                        ManualDamage(HUM,MRANDOM(15,20),HUM.Torso)
                    end
                end
                ]]

            end
        end)
        return TOUCH3
    end

    if COMBO == 1 then
        for i=0, 0.2, 0.1 / Animation_Speed do
            Swait()
            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(-6), RAD(0), RAD(-19)), 1 / Animation_Speed)
            Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(25), RAD(0), RAD(19)), 1 / Animation_Speed)
            RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(4 * COS(SINE / 12)), RAD(-70)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
            LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(4 * COS(SINE / 12)), RAD(-12)) * LEFTSHOULDERC0, 1 / Animation_Speed)
            RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(-6), RAD(85), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(0)), 1 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(-6), RAD(-85), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(0)), 1 / Animation_Speed)
        end
        CreateSound(1489705211,RightArm,MRANDOM(7,8),MRANDOM(8,13)/12,false)
        local TOUCHED = HIT()
        for i=0, 0.2, 0.1 / Animation_Speed do
            Swait()
            WACKYEFFECT({EffectType = "Sphere", Size = VT(1,1,1), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = 1, CFrame = RightArm.CFrame*CF(0,-1,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(0,1,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(130)), 1 / Animation_Speed)
            Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(25), RAD(0), RAD(-15)), 1 / Animation_Speed)
            RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(4 * COS(SINE / 12)), RAD(90)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
            LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(4 * COS(SINE / 12)), RAD(-12)) * LEFTSHOULDERC0, 1 / Animation_Speed)
            RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(0)), 1 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(0)), 1 / Animation_Speed)
        end
        TOUCHED:Disconnect()
        COMBO = 2
    elseif COMBO == 2 then
        for i=0, 0.2, 0.1 / Animation_Speed do
            Swait()
            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(15)), 1 / Animation_Speed)
            LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-90)) * ANGLES(RAD(0), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
            RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
        end
        CreateSound(1489705211,LeftArm,MRANDOM(7,8),MRANDOM(8,13)/12,false)
        local TOUCHED = HIT2()
        for i=0, 0.2, 0.1 / Animation_Speed do
            Swait()
            WACKYEFFECT({EffectType = "Box", Size = VT(1,1,1), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = 1, CFrame = LeftArm.CFrame*CF(0,-1,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = TEXTCOLOR, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-55)), 1 / Animation_Speed)
            LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, -0.5) * ANGLES(RAD(0), RAD(0), RAD(-105)) * ANGLES(RAD(90), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
            RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
        end
        TOUCHED:Disconnect()
        COMBO = 3
    elseif COMBO == 3 then
        for i=0, 0.5, 0.1 / Animation_Speed do
            Swait()
            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0.5, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(12), RAD(0), RAD(-75)), 1.5 / Animation_Speed)
            Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(75)), 1 / Animation_Speed)
            RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, -0.5, 0) * ANGLES(RAD(150), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
            LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-35), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
            RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(-12), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(-12)), 1 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(-12), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(-12)), 1 / Animation_Speed)
        end
        killnearest(RootPart.Position, 10, 55)
        CreateSound(1489705211,LeftArm,MRANDOM(7,8),MRANDOM(8,13)/12,false)
        killnearest(RightArm.Position, 10, 500)
        local TOUCHED = HIT2()
        WACKYEFFECT({Time = 25, EffectType = "Sphere", Size = VT(0,0,0), Size2 = VT(5,5,5), Transparency = 0.5, Transparency2 = 1, CFrame = RightArm.CFrame*CF(-4,0,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(0,1,0), SoundID = "444667859" , SoundPitch = 1.2, SoundVolume = 4})
        WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(0,0,0), Size2 = VT(15,15,15), Transparency = 0.5, Transparency2 = 1, CFrame = RightArm.CFrame*CF(-4,0,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(0,1,0), SoundID = "444667859" , SoundPitch = 1.2, SoundVolume = 4})
        for i=0, 0.35, 0.1 / Animation_Speed do
            Swait()
            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, -0.2, 0.5 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(12), RAD(0), RAD(45)), 1.5 / Animation_Speed)
            Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(-45)), 1 / Animation_Speed)
            RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, -0.3) * ANGLES(RAD(120), RAD(0), RAD(-25)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
            LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-45), RAD(0), RAD(-12)) * LEFTSHOULDERC0, 1 / Animation_Speed)
            RightHip.C0 = Clerp(RightHip.C0, CF(1, 0.6 - 0.05 * COS(SINE / 12), -1) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(-25)), 1 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), 0.3) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(25)), 1 / Animation_Speed)
        end
        TOUCHED:Disconnect()
        Rooted = false
        COMBO = 1
    end
    coroutine.resume(coroutine.create(function()
        for i = 1, 50 do
            Swait()
            if ATTACK == true then
                break
            end
        end
        if ATTACK == false then
            COMBO = 1
        end
    end))
    ATTACK = false
    Rooted = false
    EQUIPPED = false
end

function Joy()
    ATTACK = true
    Rooted = true
    local LOOP = true
    KEY = Mouse.KeyDown:connect(function(NEWKEY)
        if NEWKEY == "c" then
            KEY:Disconnect()
            LOOP = false
        end
    end)
    repeat
        for i = 0, 0.4, 0.1 / Animation_Speed do
            Swait()
            if LOOP == false then
                break
            end
            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.2) * ANGLES(RAD(0), RAD(0), RAD(10)), 1 / Animation_Speed)
            Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(-7), RAD(-10)), 1 / Animation_Speed)
            RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-10), RAD(0), RAD(12)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
            LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-10), RAD(0), RAD(-12)) * LEFTSHOULDERC0, 1 / Animation_Speed)
            RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.9, -0.01) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.9, -0.01) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
        end
        for i = 0, 0.4, 0.1 / Animation_Speed do
            Swait()
            if LOOP == false then
                break
            end
            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
            Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(5), RAD(0), RAD(0)), 1 / Animation_Speed)
            RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
            LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
            RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(0)), 1 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, -0.01) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(0)), 1 / Animation_Speed)
        end
        for i = 0, 0.4, 0.1 / Animation_Speed do
            Swait()
            if LOOP == false then
                break
            end
            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.2) * ANGLES(RAD(0), RAD(0), RAD(-10)), 1 / Animation_Speed)
            Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(7), RAD(10)), 1 / Animation_Speed)
            RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(10), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
            LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(10), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
            RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.9, -0.01) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.9, -0.01) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
        end
        for i = 0, 0.4, 0.1 / Animation_Speed do
            Swait()
            if LOOP == false then
                break
            end
            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
            Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-5), RAD(0), RAD(0)), 1 / Animation_Speed)
            RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(12)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
            LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-12)) * LEFTSHOULDERC0, 1 / Animation_Speed)
            RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(0), RAD(75), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 1 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, -0.01) * ANGLES(RAD(0), RAD(-75), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 1 / Animation_Speed)
        end
    until LOOP == false
    ATTACK = false
    Rooted = false
end

--//=================================\\
--||	  ASSIGN THINGS TO KEYS
--\\=================================//

-------------------------------------

Humanoid.Animator.Parent = nil

-------------------------------------


function MouseDown(Mouse)
    if ATTACK == false then
        PurgeCombo()
    end
end


function MouseUp(Mouse)
    HOLD = false
end

function KeyDown(Key)
    KEYHOLD = true
    if Key == "t" and ATTACK == false then
        Taunt()
    end

    if Key == "z" and ATTACK == false then
        Zone()
    end

    if Key == "c" and ATTACK == false then
        Joy()
    end

    if Key == "v" and ATTACK == false then
        meme()
    end

    if Key == "x" and ATTACK == false then
    end
end

function KeyUp(Key)
    KEYHOLD = false
end

Mouse.Button1Down:connect(function(NEWKEY)
    MouseDown(NEWKEY)
end)
Mouse.Button1Up:connect(function(NEWKEY)
    MouseUp(NEWKEY)
end)
Mouse.KeyDown:connect(function(NEWKEY)
    KeyDown(NEWKEY)
end)
Mouse.KeyUp:connect(function(NEWKEY)
    KeyUp(NEWKEY)
end)

--//=================================\\
--\\=================================//


function unanchor()
    if UNANCHOR == true then
        g = CharacterA:GetChildren()
        for i = 1, #g do
            if g[i].ClassName == "Part" then
                g[i].Anchored = false
            end
        end
    end
end


--//=================================\\
--||	WRAP THE WHOLE SCRIPT UP
--\\=================================//

coroutine.resume(coroutine.create(function()
    local HITFLOOR = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 4, Character)
    while true do
        Swait()
        WACKYEFFECT({EffectType = "Sphere", Size = VT(0,0,0), Size2 = VT(1.5,0.2,1), Transparency = 0, Transparency2 = 1, CFrame = RightArm.CFrame*CF(0,-1.5,0) * ANGLES(RAD(MRANDOM(-90,90)), RAD(MRANDOM(-90,90)), RAD(MRANDOM(-90,90))), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(0,1,0), SoundID = nil, SoundPitch = 1, SoundVolume = 0})
    end
end))


Humanoid.Changed:connect(function(Jump)
    if Jump == "Jump" and (Disable_Jump == true) then
        Humanoid.Jump = false
    end
end)

local CONNECT = nil

while true do
    if dead == true then
        wait()
    end
    if dead == false then
        Swait()
        ANIMATE.Parent = nil
        if Character:FindFirstChildOfClass("Humanoid") == nil then
            Humanoid = IT("Humanoid",Character)
        end
        for _,v in next, Humanoid:GetPlayingAnimationTracks() do
            v:Stop();
        end
        local TORSOVELOCITY = (RootPart.Velocity * VT(1, 0, 1)).magnitude
        local TORSOVERTICALVELOCITY = RootPart.Velocity.y
        local HITFLOOR = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 5, Character)
        local WALKSPEEDVALUE = 6 / (Humanoid.WalkSpeed / 16)
        SINE = SINE + CHANGE
        if ANIM == "Walk" and TORSOVELOCITY > 1 then
            RootJoint.C1 = Clerp(RootJoint.C1, ROOTC0 * CF(0, 0, -0.2 * COS(SINE / (WALKSPEEDVALUE))) * ANGLES(RAD(0), RAD(0) - RootPart.RotVelocity.Y / 100, RAD(0)), 2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
            Neck.C1 = Clerp(Neck.C1, CF(0, -0.5, 0) * ANGLES(RAD(-90), RAD(0), RAD(180)) * ANGLES(RAD(2.5 * SIN(SINE / (WALKSPEEDVALUE / 2))), RAD(0), RAD(0) - Head.RotVelocity.Y / 25), 0.2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
            RightHip.C1 = Clerp(RightHip.C1, CF(0.5, 1 - 0.5 * SIN(SINE / WALKSPEEDVALUE) - 0.5 * COS(SINE / WALKSPEEDVALUE*1), 0 * COS(SINE / WALKSPEEDVALUE) +0+ 0 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0) - RightLeg.RotVelocity.Y / 100, RAD(0), RAD(110 * COS(SINE / WALKSPEEDVALUE))), 0.15 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
            LeftHip.C1 = Clerp(LeftHip.C1, CF(-0.5, 1 + 0.5 * SIN(SINE / WALKSPEEDVALUE) - 0.5 * COS(SINE / WALKSPEEDVALUE*1), 0 * COS(SINE / WALKSPEEDVALUE) +0+ 0 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0) + LeftLeg.RotVelocity.Y / 100, RAD(0), RAD(110 * COS(SINE / WALKSPEEDVALUE))), 0.15 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
        elseif (ANIM ~= "Walk") or (TORSOVELOCITY < 1) then
            RootJoint.C1 = Clerp(RootJoint.C1, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
            Neck.C1 = Clerp(Neck.C1, CF(0, -0.5, 0) * ANGLES(RAD(-90), RAD(0), RAD(180)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
            RightHip.C1 = Clerp(RightHip.C1, CF(0.5, 1, 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
            LeftHip.C1 = Clerp(LeftHip.C1, CF(-0.5, 1, 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
        end
        if TORSOVERTICALVELOCITY > 1 and HITFLOOR == nil then
            ANIM = "Jump"
            if ATTACK == false then
                RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.5 / Animation_Speed)
                Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-25 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.5 / Animation_Speed)
                RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
                LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-0)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
                RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-4), RAD(0), RAD(15)), 0.5 / Animation_Speed)
                LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-4), RAD(0), RAD(0)), 0.5 / Animation_Speed)
            end
        elseif TORSOVERTICALVELOCITY < -1 and HITFLOOR == nil then
            ANIM = "Fall"
            if ATTACK == false then
                RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(-8), RAD(0), RAD(8 * SIN(SINE / 8))), 0.5 / Animation_Speed)
                Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(8 * SIN(SINE / 8))), 0.5 / Animation_Speed)
                RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(45)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
                LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-45)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
                RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(15)), 0.5 / Animation_Speed)
                LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
            end
        elseif TORSOVELOCITY < 1 and HITFLOOR ~= nil then
            ANIM = "Idle"
            if ATTACK == false then
                RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 - 0.1 * SIN(SINE / 15)) * ANGLES(RAD(0), RAD(0), RAD(-35)), 0.15 / Animation_Speed)
                Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-8 + 8 * COS(SINE / 15)), RAD(15), RAD(35)), 0.15 / Animation_Speed)
                RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.1, 0.3 - 0.1 * SIN(SINE / 15), -0.4) * ANGLES(RAD(35 - 7 * COS(SINE / 15)), RAD(5 * COS(SINE / 15)), RAD(-50)) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
                LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.1, 0.3 - 0.1 * SIN(SINE / 15), 0.2) * ANGLES(RAD(-35), RAD(-5 * COS(SINE / 15)), RAD(50)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
                RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 + 0.1 * SIN(SINE / 15), -0.01) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 0.15 / Animation_Speed)
                LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 + 0.1 * SIN(SINE / 15), -0.01) * ANGLES(RAD(0), RAD(-68), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 0.15 / Animation_Speed)
            end
        elseif TORSOVELOCITY > 1 and HITFLOOR ~= nil then
            ANIM = "Walk"
            if ATTACK == false then
                RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0.3, 0) * ANGLES(RAD(15 - 15 * COS(SINE / WALKSPEEDVALUE)), RAD(0), RAD(-5 * COS(SINE / WALKSPEEDVALUE))), 0.15 / Animation_Speed)
                Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-15 + 15 * COS(SINE / WALKSPEEDVALUE)), RAD(0), RAD(-5 * COS(SINE / WALKSPEEDVALUE))), 0.15 / Animation_Speed)
                RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(70 * COS(SINE / WALKSPEEDVALUE)), RAD(-5 * COS(SINE / WALKSPEEDVALUE)), RAD(12))* RIGHTSHOULDERC0, 0.15 / Animation_Speed)
                LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-70 * COS(SINE / WALKSPEEDVALUE)), RAD(-5 * COS(SINE / WALKSPEEDVALUE)), RAD(-12)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
                RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
                LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
            end
        end
        unanchor()
        Humanoid.MaxHealth = "inf"
        Humanoid.Health = "inf"
        if Rooted == false then
            Disable_Jump = false
            Humanoid.WalkSpeed = Speed
        elseif Rooted == true then
            Disable_Jump = true
            Humanoid.WalkSpeed = 0
        end
        if sick.Parent ~= Torso then
            sick = IT("Sound", Torso)
        end
        sick.Parent = Torso
        sick.Playing = true
        sick.Looped = true
        sick.Volume = 1
        sick.Pitch = 1
        sick.SoundId = "rbxassetid://2651212019"
        sick.Name = "Dead"
    end

end

--//=================================\\
--\\=================================//





--//====================================================\\--
--||			  		 END OF SCRIPT
--\\====================================================//--
